## 发现与评估
- 并发控制：`workflow.go` 通过 `errgroup` 与 `semaphore.Weighted` 控制并发工作流数量（`maxWorkflowConcurrency`），较合理。
- 轮询与状态：`workflow_state.go` 将数据库与队列操作包裹在带超时的上下文中，提升健壮性。
- 分发与 Worker：`dispatcher.go` 使用退避策略与失败计数，但遇到连续失败会直接返回，易导致 Worker 过早退出。
- 步骤并发：`job_builder.go:438` 并行模式下并发度等于作业数，缺少上限。
- 观测性：控制器存在工作流级 Span，但无“步骤级 Span”，定位瓶颈与失败点成本较高。
- 错误通道：`StartWorker` 未将入参 `errChan` 接入 `w.errChan`，`reportWorkerError` 最终依赖 `w.errChan` 导致上报缺失。
- ACK 频次：逐条 ACK，未批量，队列交互成本较高。
- Job 超时：`NewJobTask` 使用常量 `DefaultJobTaskTimeoutSeconds`，与 `config.Workflow.DefaultJobTimeout` 存在两套来源，建议统一。

## 优化方案
1. Worker 错误通道接线
- 在 `StartWorker` 开头将 `errChan` 赋值给 `w.errChan`，确保读取/认领错误可上报。

2. Worker 失败策略改进
- 读/认领失败不直接退出：保留退避循环，超过阈值时通过 `errChan` 上报并继续尝试，除非 `ctx.Done()` 或判定不可恢复错误。

3. 步骤级并行上限
- 新增 `ParallelMaxConcurrency`（已存在时直接使用）作为并行步骤上限，在 `determineStepConcurrency` 中应用。

4. 步骤级追踪
- 在每个 `StepExecution` 执行前创建步骤级 Span，添加 `step/priority/job_count/concurrency` 属性，并把上下文传入 `job.RunJobs`。

5. 批量 ACK
- 对同批读/认领得到的消息 ID 聚合后一次调用 `Ack(ctx, group, ids...)`。

6. Job 超时统一
- 统一以 `config.Workflow.DefaultJobTimeout` 设置 `JobTask.Timeout`，替代常量秒值，保持配置一致性。

## 预期收益
- 更稳定：避免并行步骤并发暴涨、减少 Worker 过早退出。
- 更可观测：步骤级 Span 快速定位性能与失败点。
- 更高效：批量 ACK 降低队列交互次数；错误统一进入通道便于报警与自愈。

## 后续实施（待确认）
- 接线 `errChan` 并调整失败退避逻辑
- 引入并行上限并更新并发计算
- 增加步骤级 Span 并传递上下文
- 实现批量 ACK
- 统一 Job 超时配置
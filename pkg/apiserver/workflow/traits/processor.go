package traits

import (
	"KubeMin-Cli/pkg/apiserver/domain/model"
	spec "KubeMin-Cli/pkg/apiserver/spec"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/klog/v2"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// TraitContext provides a read-only context for trait processing.
type TraitContext struct {
	Component *model.ApplicationComponent
	Workload  runtime.Object
	TraitData interface{}
}

// TraitResult holds the resources generated by a trait processor.
type TraitResult struct {
	// Pod-level modifications
	InitContainers    []corev1.Container
	Containers        []corev1.Container
	Volumes           []corev1.Volume
	VolumeMounts      map[string][]corev1.VolumeMount   // Keyed by container name
	EnvVars           map[string][]corev1.EnvVar        // Keyed by container name
	EnvFromSources    map[string][]corev1.EnvFromSource // Keyed by container name
	AdditionalObjects []client.Object
}

// TraitProcessor is the interface for all trait processors.
type TraitProcessor interface {
	Name() string
	Process(ctx *TraitContext) (*TraitResult, error)
}

// NewTraitContext creates a new trait context.
func NewTraitContext(component *model.ApplicationComponent, workload runtime.Object, traitData interface{}) *TraitContext {
	return &TraitContext{
		Component: component,
		Workload:  workload,
		TraitData: traitData,
	}
}

var (
	// orderedProcessors stores the registered trait processors in the desired execution order.
	orderedProcessors []TraitProcessor
)

// Register registers a new trait processor.
func Register(p TraitProcessor) {
	name := p.Name()
	for _, existing := range orderedProcessors {
		if existing.Name() == name {
			klog.Fatalf("Trait processor already registered: %s", name)
		}
	}
	klog.V(4).Infof("Registering trait processor: %s", name)
	orderedProcessors = append(orderedProcessors, p)
}

// RegisterAllProcessors defines the execution order for all trait processors.
func RegisterAllProcessors() {
	// 1. Register traits that define core resources first.
	Register(&StorageProcessor{})
	Register(&EnvFromProcessor{})
	Register(&EnvsProcessor{})

	// 2. Register traits that add containers or recursively process other traits.
	Register(&InitProcessor{})
	Register(&SidecarProcessor{})
	// Register other processors here as they are added.
}

// ApplyTraits is the main entry point for the trait processing system.
// It applies all registered traits to the component and returns the resulting objects.
func ApplyTraits(component *model.ApplicationComponent, workload runtime.Object) ([]client.Object, error) {
	if component.Traits == nil {
		klog.V(4).Infof("Component %s has no traits to apply.", component.Name)
		return nil, nil
	}

	traitBytes, err := json.Marshal(component.Traits)
	if err != nil {
		return nil, fmt.Errorf("failed to re-marshal traits for component %s: %w", component.Name, err)
	}

	if string(traitBytes) == "{}" || string(traitBytes) == "null" {
		return nil, nil
	}

	var traits spec.Traits
	if err := json.Unmarshal(traitBytes, &traits); err != nil {
		return nil, fmt.Errorf("failed to unmarshal traits into concrete type for component %s: %w", component.Name, err)
	}

	// Start the recursive application of traits, with no exclusions at the top level.
	finalResult, err := applyTraitsRecursive(component, workload, &traits, nil)
	if err != nil {
		return nil, err
	}

	// Apply the aggregated result to the final workload.
	if err := applyTraitResultToWorkload(finalResult, workload); err != nil {
		return nil, err
	}

	klog.V(2).Infof("Successfully applied traits for component: %s", component.Name)
	return finalResult.AdditionalObjects, nil
}

// applyTraitsRecursive is the internal, recursive core of the trait processing system.
// It takes a list of trait names to exclude to prevent infinite recursion.
func applyTraitsRecursive(component *model.ApplicationComponent, workload runtime.Object, traits *spec.Traits, excludeTraits []string) (*TraitResult, error) {
	val := reflect.ValueOf(traits).Elem()
	var allResults []*TraitResult

	// Create a map for quick lookup of excluded traits.
	excludeMap := make(map[string]bool)
	for _, t := range excludeTraits {
		excludeMap[t] = true
	}

	// Process each trait and collect results.
	for _, p := range orderedProcessors {
		traitName := p.Name()
		if excludeMap[traitName] {
			continue // Skip excluded traits.
		}

		fieldName := strings.ToUpper(traitName[:1]) + traitName[1:]
		field := val.FieldByName(fieldName)

		if !field.IsValid() || (field.Kind() == reflect.Slice && field.IsNil()) {
			continue
		}

		if field.Kind() == reflect.Slice && field.Len() > 0 {
			klog.V(3).Infof("Applying trait '%s' for component %s.", traitName, component.Name)

			ctx := NewTraitContext(component, workload, field.Interface())
			result, err := p.Process(ctx)
			if err != nil {
				return nil, fmt.Errorf("failed to process trait '%s': %w", traitName, err)
			}
			if result != nil {
				allResults = append(allResults, result)
			}
		}
	}

	// Merge all results from this level of recursion into a single result.
	return aggregateTraitResults(allResults), nil
}

// aggregateTraitResults merges multiple TraitResult objects into one, ensuring no duplicate resources.
func aggregateTraitResults(results []*TraitResult) *TraitResult {
	finalResult := &TraitResult{
		VolumeMounts:   make(map[string][]corev1.VolumeMount),
		EnvVars:        make(map[string][]corev1.EnvVar),
		EnvFromSources: make(map[string][]corev1.EnvFromSource),
	}
	// Use maps to track the names of added volumes and objects to prevent duplicates.
	volumeNameSet := make(map[string]bool)
	objectNameSet := make(map[string]bool)
	volumeMountSet := make(map[string]map[string]bool) // containerName -> mountPath -> exists

	for _, res := range results {
		finalResult.InitContainers = append(finalResult.InitContainers, res.InitContainers...)
		finalResult.Containers = append(finalResult.Containers, res.Containers...)

		// De-duplicate Volumes
		for _, vol := range res.Volumes {
			if !volumeNameSet[vol.Name] {
				finalResult.Volumes = append(finalResult.Volumes, vol)
				volumeNameSet[vol.Name] = true
			}
		}

		// De-duplicate AdditionalObjects
		for _, obj := range res.AdditionalObjects {
			// Use "Kind/Namespace/Name" as the unique identifier.
			key := fmt.Sprintf("%s/%s/%s", obj.GetObjectKind().GroupVersionKind().Kind, obj.GetNamespace(), obj.GetName())
			if !objectNameSet[key] {
				finalResult.AdditionalObjects = append(finalResult.AdditionalObjects, obj)
				objectNameSet[key] = true
			}
		}

		// Merge and de-duplicate VolumeMounts by container name and mount path.
		for containerName, mounts := range res.VolumeMounts {
			if _, ok := volumeMountSet[containerName]; !ok {
				volumeMountSet[containerName] = make(map[string]bool)
			}
			for _, mount := range mounts {
				if !volumeMountSet[containerName][mount.MountPath] {
					finalResult.VolumeMounts[containerName] = append(finalResult.VolumeMounts[containerName], mount)
					volumeMountSet[containerName][mount.MountPath] = true
				}
			}
		}

		// Merge EnvVars by container name.
		for containerName, envs := range res.EnvVars {
			finalResult.EnvVars[containerName] = append(finalResult.EnvVars[containerName], envs...)
		}

		// Merge EnvFromSources by container name.
		for containerName, envs := range res.EnvFromSources {
			finalResult.EnvFromSources[containerName] = append(finalResult.EnvFromSources[containerName], envs...)
		}
	}
	return finalResult
}

// applyTraitResultToWorkload applies the final, aggregated result to the workload.
// It handles special cases like StatefulSets intelligently.
func applyTraitResultToWorkload(result *TraitResult, workload runtime.Object) error {
	podTemplate, err := getPodTemplateFromWorkload(workload)
	if err != nil {
		return err
	}

	podTemplate.Spec.InitContainers = append(podTemplate.Spec.InitContainers, result.InitContainers...)
	podTemplate.Spec.Containers = append(podTemplate.Spec.Containers, result.Containers...)
	podTemplate.Spec.Volumes = append(podTemplate.Spec.Volumes, result.Volumes...)

	// Create a map of all containers (main, init, sidecar) for easy lookup.
	containerMap := make(map[string]*corev1.Container)
	for i := range podTemplate.Spec.Containers {
		containerMap[podTemplate.Spec.Containers[i].Name] = &podTemplate.Spec.Containers[i]
	}
	for i := range podTemplate.Spec.InitContainers {
		containerMap[podTemplate.Spec.InitContainers[i].Name] = &podTemplate.Spec.InitContainers[i]
	}

	// Apply VolumeMounts to the correct containers.
	for containerName, mounts := range result.VolumeMounts {
		if c, ok := containerMap[containerName]; ok {
			c.VolumeMounts = append(c.VolumeMounts, mounts...)
		} else {
			klog.Warningf("Could not find container '%s' to apply volume mounts.", containerName)
		}
	}

	// Apply EnvVars to the correct containers.
	for containerName, envs := range result.EnvVars {
		if c, ok := containerMap[containerName]; ok {
			c.Env = append(c.Env, envs...)
		} else {
			klog.Warningf("Could not find container '%s' to apply env vars.", containerName)
		}
	}

	// Apply EnvFromSources to the correct containers.
	for containerName, envs := range result.EnvFromSources {
		if c, ok := containerMap[containerName]; ok {
			c.EnvFrom = append(c.EnvFrom, envs...)
		} else {
			klog.Warningf("Could not find container '%s' to apply env from sources.", containerName)
		}
	}

	// Intelligent PVC handling: check if the workload is a StatefulSet.
	if sts, ok := workload.(*appsv1.StatefulSet); ok {
		var remainingObjects []client.Object
		for _, obj := range result.AdditionalObjects {
			if pvc, isPVC := obj.(*corev1.PersistentVolumeClaim); isPVC {
				sts.Spec.VolumeClaimTemplates = append(sts.Spec.VolumeClaimTemplates, *pvc)
			} else {
				remainingObjects = append(remainingObjects, obj)
			}
		}
		result.AdditionalObjects = remainingObjects
	}

	return nil
}

// getPodTemplateFromWorkload is a helper to get the PodTemplateSpec from a runtime.Object.
func getPodTemplateFromWorkload(workload runtime.Object) (*corev1.PodTemplateSpec, error) {
	switch w := workload.(type) {
	case *appsv1.Deployment:
		return &w.Spec.Template, nil
	case *appsv1.StatefulSet:
		return &w.Spec.Template, nil
	case *appsv1.DaemonSet:
		return &w.Spec.Template, nil
	default:
		return nil, fmt.Errorf("unsupported workload type: %T", workload)
	}
}

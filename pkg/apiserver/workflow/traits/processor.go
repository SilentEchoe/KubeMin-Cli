package traits

import (
	"KubeMin-Cli/pkg/apiserver/domain/model"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/klog/v2"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// TraitContext provides a read-only context for trait processing.
type TraitContext struct {
	Component *model.ApplicationComponent
	Workload  runtime.Object
	TraitData interface{}
}

// TraitResult holds the resources generated by a trait processor.
type TraitResult struct {
	// Pod-level modifications
	InitContainers []corev1.Container
	Containers     []corev1.Container
	Volumes        []corev1.Volume
	VolumeMounts   map[string][]corev1.VolumeMount // Keyed by container name
	// Cluster-level objects to be created alongside the workload
	AdditionalObjects []client.Object
}

// TraitProcessor is the interface for all trait processors.
type TraitProcessor interface {
	Name() string
	Process(ctx *TraitContext) (*TraitResult, error)
}

// NewTraitContext creates a new trait context.
func NewTraitContext(component *model.ApplicationComponent, workload runtime.Object, traitData interface{}) *TraitContext {
	return &TraitContext{
		Component: component,
		Workload:  workload,
		TraitData: traitData,
	}
}

// GetPodTemplate gets the PodTemplateSpec from the workload.
func (ctx *TraitContext) GetPodTemplate() (*corev1.PodTemplateSpec, error) {
	switch w := ctx.Workload.(type) {
	case *appsv1.Deployment:
		return &w.Spec.Template, nil
	case *appsv1.StatefulSet:
		return &w.Spec.Template, nil
	case *appsv1.DaemonSet:
		return &w.Spec.Template, nil
	default:
		return nil, fmt.Errorf("unsupported workload type: %T", ctx.Workload)
	}
}

var (
	// orderedProcessors stores the registered trait processors in the desired execution order.
	orderedProcessors []TraitProcessor
)

// Register registers a new trait processor.
func Register(p TraitProcessor) {
	name := p.Name()
	for _, existing := range orderedProcessors {
		if existing.Name() == name {
			klog.Fatalf("Trait processor already registered: %s", name)
		}
	}
	klog.V(4).Infof("Registering trait processor: %s", name)
	orderedProcessors = append(orderedProcessors, p)
}

// ApplyTraits applies all registered traits to the component and returns the resulting objects.
func ApplyTraits(component *model.ApplicationComponent, workload runtime.Object) ([]client.Object, error) {
	if component.Traits == nil {
		klog.V(4).Infof("Component %s has no traits to apply.", component.Name)
		return nil, nil
	}

	traitBytes, err := json.Marshal(component.Traits)
	if err != nil {
		return nil, fmt.Errorf("failed to re-marshal traits for component %s: %w", component.Name, err)
	}

	if string(traitBytes) == "{}" || string(traitBytes) == "null" {
		return nil, nil
	}

	var traits model.Traits
	if err := json.Unmarshal(traitBytes, &traits); err != nil {
		return nil, fmt.Errorf("failed to unmarshal traits into concrete type for component %s: %w", component.Name, err)
	}

	// model.Traits 结构体的反射对象，可以通过它来检查和获取结构体的字段
	val := reflect.ValueOf(traits)
	var allResults []*TraitResult

	// Process each trait and collect results
	for _, p := range orderedProcessors {
		// 获取当前处理器的名字
		traitName := p.Name()
		// Trait 的名字（通常是小写开头）转换为 Go 语言结构体字段的标准命名风格（大写开头，即 "CamelCase"）
		fieldName := strings.ToUpper(traitName[:1]) + traitName[1:]
		// 使用反射，在 val (代表 model.Traits 结构体) 中，根据我们刚刚构建的 fieldName ("Storage", "Sidecar" 等) 查找同名字段。
		field := val.FieldByName(fieldName)
		
		if !field.IsValid() || (field.Kind() == reflect.Slice && field.IsNil()) {
			continue
		}

		if field.Kind() == reflect.Slice && field.Len() > 0 {
			klog.V(3).Infof("Applying trait '%s' for component %s.", traitName, component.Name)

			ctx := NewTraitContext(component, workload, field.Interface())
			result, err := p.Process(ctx)
			if err != nil {
				return nil, fmt.Errorf("failed to process trait '%s': %w", traitName, err)
			}
			if result != nil {
				allResults = append(allResults, result)
			}
		}
	}

	// Aggregate all results and apply them
	finalResult := aggregateTraitResults(allResults)
	if err := applyTraitResultToWorkload(finalResult, workload); err != nil {
		return nil, err
	}

	klog.V(2).Infof("Successfully applied traits for component: %s", component.Name)
	return finalResult.AdditionalObjects, nil
}

// aggregateTraitResults merges multiple TraitResult objects into one.
func aggregateTraitResults(results []*TraitResult) *TraitResult {
	finalResult := &TraitResult{
		VolumeMounts: make(map[string][]corev1.VolumeMount),
	}

	for _, res := range results {
		finalResult.InitContainers = append(finalResult.InitContainers, res.InitContainers...)
		finalResult.Containers = append(finalResult.Containers, res.Containers...)
		finalResult.Volumes = append(finalResult.Volumes, res.Volumes...)
		finalResult.AdditionalObjects = append(finalResult.AdditionalObjects, res.AdditionalObjects...)

		for containerName, mounts := range res.VolumeMounts {
			finalResult.VolumeMounts[containerName] = append(finalResult.VolumeMounts[containerName], mounts...)
		}
	}
	return finalResult
}

// applyTraitResultToWorkload applies the aggregated result to the workload.
// It handles special cases like StatefulSets intelligently.
func applyTraitResultToWorkload(result *TraitResult, workload runtime.Object) error {
	podTemplate, err := getPodTemplateFromWorkload(workload)
	if err != nil {
		return err
	}

	podTemplate.Spec.InitContainers = append(podTemplate.Spec.InitContainers, result.InitContainers...)
	podTemplate.Spec.Containers = append(podTemplate.Spec.Containers, result.Containers...)
	podTemplate.Spec.Volumes = append(podTemplate.Spec.Volumes, result.Volumes...)

	// Create a map of containers for easy lookup
	containerMap := make(map[string]*corev1.Container)
	for i := range podTemplate.Spec.Containers {
		containerMap[podTemplate.Spec.Containers[i].Name] = &podTemplate.Spec.Containers[i]
	}

	for containerName, mounts := range result.VolumeMounts {
		if c, ok := containerMap[containerName]; ok {
			c.VolumeMounts = append(c.VolumeMounts, mounts...)
		} else {
			klog.Warningf("Could not find container '%s' to apply volume mounts.", containerName)
		}
	}

	// Intelligent PVC handling: check if the workload is a StatefulSet
	if sts, ok := workload.(*appsv1.StatefulSet); ok {
		var remainingObjects []client.Object
		for _, obj := range result.AdditionalObjects {
			if pvc, isPVC := obj.(*corev1.PersistentVolumeClaim); isPVC {
				// If it's a PVC and the workload is a StatefulSet, absorb it into VolumeClaimTemplates
				sts.Spec.VolumeClaimTemplates = append(sts.Spec.VolumeClaimTemplates, *pvc)
			} else {
				// Otherwise, it's a genuine additional object
				remainingObjects = append(remainingObjects, obj)
			}
		}
		// The original list is replaced by the list of non-PVC objects
		result.AdditionalObjects = remainingObjects
	}

	return nil
}

// getPodTemplateFromWorkload is a helper to get the PodTemplateSpec from a runtime.Object.
func getPodTemplateFromWorkload(workload runtime.Object) (*corev1.PodTemplateSpec, error) {
	switch w := workload.(type) {
	case *appsv1.Deployment:
		return &w.Spec.Template, nil
	case *appsv1.StatefulSet:
		return &w.Spec.Template, nil
	case *appsv1.DaemonSet:
		return &w.Spec.Template, nil
	default:
		return nil, fmt.Errorf("unsupported workload type: %T", workload)
	}
}
